# -*- coding: utf-8 -*-
"""
/***************************************************************************
 File_ReaderDialog
                                 A QGIS plugin
 File_Reader
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-08-08
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Arielle Simmons-Steffen
        email                : ari.ucb.fire@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import time
from pathlib import Path
import glob
import pandas as pd

from qgis.PyQt import uic
from osgeo import ogr, gdal

from qgis.PyQt import uic, QtWidgets, QtGui

from qgis.core import QgsVectorLayer, QgsRasterLayer


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), "File_Reader_dialog_base.ui"))


def output_to_csv(df, output_folder, output_file_name, output_file_extension, index=None):
    if index is not None:
        output_file_path = output_folder + "/" + output_file_name + "_" + str(index) + output_file_extension
    else:
        output_file_path = output_folder + "/" + output_file_name + output_file_extension

    if os.path.exists(output_file_path):
        output_to_csv(
            df, output_folder, output_file_name, output_file_extension, index=index + 1 if index is not None else 1
        )
    else:
        df.to_csv(output_file_path, index=False)


class File_ReaderDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(File_ReaderDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.process_files.clicked.connect(lambda: self.on_process_files_click())

    def get_path_data(self, path, input_folder_path):
        path = Path(path)

        basename = path.stem + path.suffix
        data_type = path.suffix

        full_path = str(path.parent).split(input_folder_path.parent.stem, 1)[1]

        created = os.path.getctime(path)
        local_created = time.strftime("%m/%d/%Y - %H:%M:%S", time.localtime(created))

        modified = os.path.getmtime(path)
        local_modified = time.strftime("%m/%d/%Y - %H:%M:%S", time.localtime(modified))

        access = os.path.getatime(path)
        local_access = time.strftime("%m/%d/%Y - %H:%M:%S", time.localtime(access))

        return (basename, data_type, full_path, local_created, local_modified, local_access)

    def get_projection(self, file_path):
        try:
            layer = QgsVectorLayer(file_path, "", "ogr")

            # If not valid, try loading as a raster layer
            if not layer.isValid():
                layer = QgsRasterLayer(file_path, "")
                if not layer.isValid():
                    return

            # Extract CRS details
            crs = layer.crs()
            crs = f"{crs.authid()} - {crs.description()}"
            if crs == " - unnamed":
                crs = "Projection is unnamed because it isn't listed in the predefined library. Please verify manually"
            elif crs == " - ":
                crs = "Unknown"
            return crs
        except:
            return

    def is_geodatabase(self, folder_path):
        # driver = ogr.GetDriverByName('OpenFileGDB')
        # if not driver:
        #     raise Exception("Driver not available. Ensure you have the OpenFileGDB driver with your GDAL installation.")

        dataset = ogr.Open(folder_path)
        if dataset is None:
            return None, None
        driver = dataset.GetDriver().GetName()
        return dataset, driver

    def load_mdb_layer(self, mdb_path, table_name):
        layer = QgsVectorLayer(mdb_path, table_name, "ogr")
        if not layer.isValid():
            print("Layer failed to load!")
            return None

        return layer

    def list_mdb_layers(self, mdb_path):
        # Load the MDB file as a dataset
        dataset = QgsVectorLayer(mdb_path, "", "ogr")

        if not dataset.isValid():
            raise ValueError("Failed to load the mdb dataset!")

        sublayers = dataset.dataProvider().subLayers()
        tables = []
        layers = []

        for sublayer in sublayers:
            try:
                details = [t.strip("!") for t in sublayer.split("::")][1:-1]
                details.pop(1)

                table_name, data_type, file_type = details

                if data_type == "None":
                    tables.append(table_name)
                else:
                    try:
                        layer = self.load_mdb_layer(mdb_path, table_name)
                        crs = layer.crs()
                        projection = f"{crs.authid()} - {crs.description()}"
                        layers.append((table_name, projection))
                    except:
                        layers.append((table_name, None))

            except Exception as e:
                print(e)
                pass

        return tables, layers

    def get_custom_projection_format(self, spatial_ref):
        try:
            if spatial_ref:
                projection_info = spatial_ref.GetAttrValue("PROJCS")
                projection_auth_name = spatial_ref.GetAttrValue("AUTHORITY", 0)
                projection_authid = spatial_ref.GetAttrValue("AUTHORITY", 1)

                if projection_info in ["", "unnamed", None]:
                    projection_info = spatial_ref.GetAttrValue("GEOGCS")

                return f"{projection_auth_name}:{projection_authid} - {projection_info}"
        except:
            pass

        return "Unknown"

    def list_coverage_files(self, coverage_path):
        # Register all OGR drivers
        ogr.RegisterAll()

        all_layers = []

        # Open the coverage data source
        datasource = ogr.Open(coverage_path)

        if datasource is None:
            print("Failed to open the coverage.")
            return

        # Loop through all layers (feature classes) and print their names
        for i in range(datasource.GetLayerCount()):
            layer = datasource.GetLayerByIndex(i)
            if layer:
                projection = self.get_custom_projection_format(layer.GetSpatialRef())

                layer_name = layer.GetName()

                file_type = ""

                for file_path in glob.glob(coverage_path + os.sep + "*"):
                    file_path = Path(file_path)
                    file_name = file_path.stem

                    if layer_name.lower() == file_name.lower():
                        file_type = file_path.suffix

                all_layers.append((layer_name, file_type, projection))

        return all_layers

    def on_process_files_click(self):
        input_folder = self.input_folder.filePath()
        output_folder = self.output_folder.filePath()

        adf_folders = set()
        mdb_files = []
        jpg_files = set()
        adf_folders_non_coverage = set()

        self.root_folder = os.path.basename(input_folder)

        for root, dirs, files in os.walk(input_folder):
            for file in files:
                if file.endswith((".mdb", ".adf", ".jpg", ".jp2")):
                    file_path = os.path.join(root, file)
                    valid_folder = str(Path(file_path).parent.absolute())

                    dataset, driver = self.is_geodatabase(valid_folder)

                    if dataset is not None:
                        if file.endswith(".adf"):
                            adf_folders.add((valid_folder, driver))
                    else:
                        if file.endswith(".adf"):
                            adf_folders_non_coverage.add(valid_folder)
                        elif file.endswith(".mdb"):
                            mdb_files.append(file_path)
                        elif file.endswith(".jpg") or file.endswith(".jp2"):
                            jpg_files.add(file_path)

        df = pd.DataFrame(
            columns=[
                "base_folder",
                "full_path",
                "basename",
                "data_type",
                "created",
                "modified",
                "accessed",
                "source",
                "numeric_range_of_values",
                "projection",
            ]
        )

        for folder_path, driver_name in adf_folders:
            (basename, data_type, full_path, local_created, local_modified, local_access) = self.get_path_data(
                folder_path, Path(input_folder)
            )

            all_layers = self.list_coverage_files(folder_path)

            for layer_data in all_layers:
                (layer_name, data_type, projection) = layer_data

                df = df.append(
                    {
                        "base_folder": os.sep + self.root_folder,
                        "full_path": full_path + os.sep + layer_name,
                        "basename": basename,
                        "data_type": "coverage",
                        "created": local_created,
                        "modified": local_modified,
                        "accessed": local_access,
                        "source": "",
                        "numeric_range_of_values": "",
                        "projection": projection,
                    },
                    ignore_index=True,
                )

        for folder_path in adf_folders_non_coverage:
            main_file = None
            file_size_list = []

            for file in glob.glob(os.path.join(folder_path, "*.adf")):
                file_size = os.path.getsize(file)
                file_size_list.append((file, file_size))

                if Path(file).stem == "w001001":
                    main_file = file

            if main_file is None:
                main_file = sorted(file_size_list, key=lambda x: x[1])[-1][0]

            if main_file is not None:
                (basename, data_type, full_path, local_created, local_modified, local_access) = self.get_path_data(
                    main_file, Path(input_folder)
                )

                min_elv, max_elv = self.get_elevation_units(main_file)

                projection = self.get_projection(main_file)

                df = df.append(
                    {
                        "base_folder": os.sep + self.root_folder,
                        "full_path": full_path,
                        "basename": basename,
                        "data_type": data_type,
                        "created": local_created,
                        "modified": local_modified,
                        "accessed": local_access,
                        "source": "",
                        "numeric_range_of_values": (min_elv, max_elv) if min_elv is not None else "",
                        "projection": projection if projection is not None else "Unknown",
                    },
                    ignore_index=True,
                )

        for file_path in mdb_files:
            (basename, data_type, full_path, local_created, local_modified, local_access) = self.get_path_data(
                file_path, Path(input_folder)
            )

            tables, layers_data = self.list_mdb_layers(file_path)

            for attrs in tables:
                df = df.append(
                    {
                        "base_folder": os.sep + self.root_folder,
                        "full_path": full_path + os.sep + attrs,
                        "basename": basename,
                        "data_type": data_type,
                        "created": local_created,
                        "modified": local_modified,
                        "accessed": local_access,
                        "source": "",
                        "numeric_range_of_values": "",
                        "projection": "Unknown",
                    },
                    ignore_index=True,
                )

            for layer_name, projection in layers_data:
                df = df.append(
                    {
                        "base_folder": os.sep + self.root_folder,
                        "full_path": full_path + os.sep + layer_name,
                        "basename": basename,
                        "data_type": data_type,
                        "created": local_created,
                        "modified": local_modified,
                        "accessed": local_access,
                        "source": "",
                        "numeric_range_of_values": "",
                        "projection": projection if projection is not None else "Unknown",
                    },
                    ignore_index=True,
                )

        for file_path in jpg_files:
            (basename, data_type, full_path, local_created, local_modified, local_access) = self.get_path_data(
                file_path, Path(input_folder)
            )

            projection = self.get_projection(file_path)

            df = df.append(
                {
                    "base_folder": os.sep + self.root_folder,
                    "full_path": full_path,
                    "basename": basename,
                    "data_type": data_type,
                    "created": local_created,
                    "modified": local_modified,
                    "accessed": local_access,
                    "source": "",
                    "numeric_range_of_values": "",
                    "projection": projection if projection is not None else "Unknown",
                },
                ignore_index=True,
            )

        df["created"] = df["created"].astype("str")
        df["modified"] = df["modified"].astype("str")
        df["accessed"] = df["accessed"].astype("str")

        output_file_name, output_file_extension = ("output", ".csv")

        output_to_csv(df, output_folder, output_file_name, output_file_extension)

    def get_elevation_units(self, input_file):
        if input_file is None:
            return None, None

        dataset = gdal.Open(input_file)

        if dataset is None:
            return None, None

        try:
            band = dataset.GetRasterBand(1)

            # Get the minimum and maximum elevation values
            min_elevation = band.GetMinimum()
            max_elevation = band.GetMaximum()

            if min_elevation is None or max_elevation is None:
                # If the minimum and maximum are not set, compute them
                min_elevation, max_elevation = band.ComputeRasterMinMax()

            return min_elevation, max_elevation
        except:
            return None, None
